name: CD - Continuous Deployment

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment target environment'
        required: true
        type: choice
        default: 'production'
        options:
          - production
          - staging
          - development
      docker_tag:
        description: 'Docker image tag to deploy'
        required: false
        type: string
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: write
  packages: write

jobs:
  # ===========================================================================
  # Build and Push Docker Images with LFS
  # ===========================================================================
  build-push:
    runs-on: ubuntu-latest
    outputs:
      backend_tag: ${{ steps.meta-backend.outputs.tags }}
      frontend_tag: ${{ steps.meta-frontend.outputs.tags }}
    steps:
      - name: Checkout code with LFS
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Pull LFS files
        run: |
          git lfs pull
          echo "=== LFS Model Status ==="
          if [ -f "model/finetuned_best_model.pth" ]; then
            echo "‚úì Model file found for Docker build"
            ls -lh model/finetuned_best_model.pth
            sha256sum model/finetuned_best_model.pth
          else
            echo "‚ùå ERROR: Model file not found!"
            echo "Available files in model/:"
            ls -la model/ || echo "model/ directory does not exist"
            exit 1
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ inputs.docker_tag }},enable=${{ github.event_name == 'workflow_dispatch' }}

      - name: Build and push Backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha,scope=backend-prod
          cache-to: type=gha,mode=max,scope=backend-prod
          platforms: linux/amd64

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ inputs.docker_tag }},enable=${{ github.event_name == 'workflow_dispatch' }}

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha,scope=frontend-prod
          cache-to: type=gha,mode=max,scope=frontend-prod
          platforms: linux/amd64

      - name: Image digest
        run: |
          echo "Backend: ${{ steps.meta-backend.outputs.tags }}"
          echo "Frontend: ${{ steps.meta-frontend.outputs.tags }}"

  # ===========================================================================
  # Deploy to Cloud Server
  # ===========================================================================
  deploy:
    runs-on: ubuntu-latest
    needs: build-push
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ inputs.environment || 'production' }}
      url: ${{ secrets.APP_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment package
        run: |
          tar czf deploy.tar.gz docker-compose.yml nginx.conf .env.example Makefile

      - name: Copy files to server
        run: |
          scp deploy.tar.gz ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/

      - name: Deploy to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            
            APP_DIR="${{ secrets.APP_DIR }}"
            if [ -z "$APP_DIR" ]; then
              APP_DIR="/opt/packet-inspection"
            fi
            
            echo "=== Deployment Started ==="
            
            sudo mkdir -p "$APP_DIR"
            cd "$APP_DIR"
            
            sudo tar xzf /tmp/deploy.tar.gz
            rm /tmp/deploy.tar.gz
            
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            echo "=== Pulling Docker images ==="
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:latest
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:latest
            
            echo "=== Stopping existing containers ==="
            docker compose --profile prod down || true
            
            echo "=== Starting new containers ==="
            docker compose --profile prod up -d
            
            echo "=== Cleaning up ==="
            docker image prune -f
            
            echo "=== Deployment Complete ==="
          ENDSSH

      - name: Wait for services to be healthy
        run: |
          echo "Waiting for services to start..."
          sleep 15

      - name: Health check
        run: |
          BACKEND_URL="${{ secrets.APP_URL }}/health"
          FRONTEND_URL="${{ secrets.APP_URL }}"
          
          echo "Checking backend health: $BACKEND_URL"
          for i in {1..10}; do
            if curl -f -s "$BACKEND_URL" > /dev/null; then
              echo "‚úì Backend is healthy"
              break
            fi
            echo "Attempt $i/10 failed, waiting..."
            sleep 5
          done
          
          echo "Checking frontend: $FRONTEND_URL"
          if curl -f -s "$FRONTEND_URL" > /dev/null; then
            echo "‚úì Frontend is accessible"
          else
            echo "‚ö† Frontend health check failed"
          fi

      - name: Deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úì Deployment to ${{ inputs.environment || 'production' }} succeeded"
          else
            echo "‚ùå Deployment to ${{ inputs.environment || 'production' }} failed"
          fi

  # ===========================================================================
  # Create GitHub Release
  # ===========================================================================
  create-release:
    runs-on: ubuntu-latest
    needs: deploy
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          PREVIOUS_TAG=$(git tag --sort=-version:refname | sed -n '2p')
          if [ -z "$PREVIOUS_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGELOG=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          body: |
            ## üöÄ Release ${{ github.ref_name }}
            
            ### üì¶ Docker Images
            - Backend: `ghcr.io/${{ github.repository }}/backend:${{ github.ref_name }}`
            - Frontend: `ghcr.io/${{ github.repository }}/frontend:${{ github.ref_name }}`
            
            ### üìù Changes
            ${{ steps.changelog.outputs.changelog }}
            
            ### üîó Deployment
            Environment: ${{ inputs.environment || 'production' }}
            URL: ${{ secrets.APP_URL }}
          draft: false
          prerelease: ${{ contains(github.ref_name, 'rc') || contains(github.ref_name, 'beta') || contains(github.ref_name, 'alpha') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ===========================================================================
  # Rollback (Manual trigger only)
  # ===========================================================================
  rollback:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && inputs.environment != ''
    environment:
      name: rollback-${{ inputs.environment }}
    steps:
      - name: Rollback confirmation
        run: |
          echo "‚ö†Ô∏è Rollback can be triggered manually from GitHub Actions UI"
          echo "Use workflow_dispatch with previous docker_tag to rollback"

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Rollback deployment
        if: inputs.docker_tag != 'latest'
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            APP_DIR="${{ secrets.APP_DIR }}"
            if [ -z "$APP_DIR" ]; then
              APP_DIR="/opt/packet-inspection"
            fi
            
            cd "$APP_DIR"
            
            echo "=== Rolling back to ${{ inputs.docker_tag }} ==="
            
            sed -i 's|:latest|:${{ inputs.docker_tag }}|g' docker-compose.yml
            
            docker compose --profile prod pull
            docker compose --profile prod up -d
            
            echo "=== Rollback complete ==="
          ENDSSH
